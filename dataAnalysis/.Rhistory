group1 = "source", group2 = "target",
p= round(row$p_value,3))
p_i <- ggbarplot(
df_plot,
x = "letterType",
y = "accuracy",
color = "letterType",
fill = "letterType",
palette = c("#00AFBB", "#E7B800"),  #
position = position_dodge(0.8),
alpha = 0.2,
size = 0.8,
width = 0.6,
) +
geom_errorbar(
aes(ymin = accuracy - se, ymax = accuracy + se),
width = 0.2,
position = position_dodge(0.8)
) +
# Add horizontal line for chance level
geom_hline(
yintercept = 1/9,
linetype = "dashed",
color = "red",
linewidth = 1
) +
# Add chance level annotation
annotate(
"text",
x = 1.5,
y = 1/9 + 0.02,
label = paste0("Chance level = ", round(1/9, 3)),
color = "red",
size = 3.5
) +
# Add statistical comparison
stat_pvalue_manual(
manual_p,
label = "p = {p}",
tip.length = -0.01,
y.position = max(df_plot$accuracy, na.rm = TRUE) - 0.2
) +
# Customize appearance
labs(
#title = "Accuracy in source vs target task",
#subtitle = paste0("n = ", desc_stats$n[1], " participants"),
x = data$treatment[[i]],
y = "Accuracy",
caption = "Error bars = s.e. of the mean on each side"
) +
theme_pubr() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
) +
scale_y_continuous(
limits = c(0, 1),
breaks = seq(0, 1, 0.1),
labels = scales::percent_format(accuracy = 1)
)
plots[[i]] <- p_i
}
# arrange side-by-side (will handle 1 or 2 rows automatically)
ncol <- min(2, length(plots))
combined <- ggpubr::ggarrange(plotlist = plots, ncol = ncol, nrow = ceiling(length(plots)/ncol))
combined<-annotate_figure(combined, top = text_grob("Accuracy in source vs target task depending on cognitive load", face = "bold", size = 14))
return(combined)
}
barPlotAccuracySourceVsTarget <- makePlotAccuracySourceVsTarget(mean_accuracy_perParticipants)
barPlotAccuracySourceVsTarget
ggsave(filename = file.path(PATH_TO_DATA, "Figures", "barPlotAccuracySourceVsTarget.pdf"),
plot = barPlotAccuracySourceVsTarget, device = "pdf", width = 8, height = 5)
makeScatterPlotAccuracyOnSpan <- function (data, acc) {
plots <- list()
for (i in acc){
ac <- i
if (!ac %in% names(data)) {
plots[[i]] <- ggplot() + labs(title = paste0("variable '", ac, "' not found"))
next
}
if (ac == "accuracy_difference") {
y_limit <- c(-1, 1)
y_break <- seq(-1, 1, 0.2)
cat(y_limit, "is y_limit \n")
} else {
y_limit <- c(0, 1)
y_break <- seq(0, 1, 0.1)
cat(y_limit, "is y_limit \n")
}
p <- ggscatter(
data,
x = "spanLength",
y = ac,
#color = "letterType",
#fill = "letterType",
#palette = c("#00AFBB", "#E7B800"),  # Easy = blue, Hard = yellow
add = "reg.line",
add.params = list(color = "blue"),
alpha = 0
) +
geom_count(aes(x = spanLength, y = .data[[ac]]), colour = "black", fill = "#2c7fb8",
show.legend = FALSE, alpha = 0.75) +
scale_size_area(max_size = 10) +
# Add horizontal line
geom_hline(
yintercept = 0,
linetype =  "solid",
color = "black",
linewidth = 0.5
) +
# Customize appearance
labs(
#title = "Accuracy depending on maxSpan",
#subtitle = paste0("n = ", desc_stats$n[1], " participants"),
x = "maximum span achieved at calibration",
y = ac
) +
theme_pubr() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
) +
scale_y_continuous(
limits = y_limit,
breaks = y_break,
labels = scales::percent_format(accuracy = 1)
)
plots[[i]] <- p
}
combined <- ggpubr::ggarrange(plotlist = plots, ncol = length(plots), nrow = 1)
combined <- annotate_figure(combined, top = text_grob("Accuracies on maximum span achieved", face = "bold", size = 14)) # ))color = "red",
return(combined)
}
scatterAccuracyOnSpan <- makeScatterPlotAccuracyOnSpan(mean_accuracy_perParticipants, c("accuracy_source", "accuracy_target", "accuracy_difference"))
scatterAccuracyOnSpan
ggsave(filename = file.path(PATH_TO_DATA, "Figures", "scatterAccuracyOnSpan.pdf"),
plot = scatterAccuracyOnSpan, device = "pdf", width = 12, height = 8)
makeScatterRTOnCogLoad <- function (data) {
plotFunction <- function (acc, rt){
p <- ggscatter(
data,
x = rt,
y = acc,
#color = "letterType",
#fill = "letterType",
#palette = c("#00AFBB", "#E7B800"),  # Easy = blue, Hard = yellow
add = "reg.line",
add.params = list(color = "blue"),
) +
# Customize appearance
labs(
#title = "accuracy on rt",
#subtitle = paste0("n = ", desc_stats$n[1], " participants"),
x = rt,
y = acc,
#caption = "Error bars = s.e. of the mean on each side"
) +
theme_pubr() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
) +
scale_y_continuous(
limits = c(0, 1),
breaks = seq(0, 1, 0.2),
labels = scales::percent_format(accuracy = 1)
)
}
accuracy_names <- c("accuracy_target", "accuracy_source")
rt_names <- c("rt_r_source", "rt_m_source", "rt_target")
plots <- vector("list", length(accuracy_names) * length(rt_names))
counter = 1
for (acc in accuracy_names){
for (rt in rt_names){
plots[[counter]] <- plotFunction(acc,rt)
counter <- counter + 1
}
}
combined <- ggpubr::ggarrange(plotlist = plots, ncol = 3, nrow = 2)
combined <- annotate_figure(combined, top = text_grob("Accuracies on RT", face = "bold", size = 14))
}
scatterRTOnCogLoad <- makeScatterRTOnCogLoad(mean_accuracy_perParticipants)
scatterRTOnCogLoad
ggsave(filename = file.path(PATH_TO_DATA, "Figures", "scatterRTOnCogLoad.pdf"),
plot = scatterRTOnCogLoad, device = "pdf", width = 12, height = 6)
# see if people in cognitive load take more time to memorize their source span (rt_m_source)
dataRtMSourcePerTreatment <- mean_accuracy_perParticipants %>%
group_by(treatment) %>%
summarise(
n = n(),
mean_rt_m_source = mean(rt_m_source),
median_rt_m_source = median(rt_m_source),
sd_rt_m_source = sd(rt_m_source),
se_rt_m_source = sd(rt_m_source)/sqrt(n())
) %>%
ungroup()
makeRtMSourcePerTreatment <- function(data){
p <- ggbarplot(
data,
x = "treatment",
y = "median_rt_m_source",
color = "treatment",
fill = "treatment",
palette = c("#00AFBB", "#E7B800"),
position = position_dodge(0.8),
alpha = 0.2,
size = 0.8,
width = 0.6,
) +
geom_errorbar(
aes(ymin = median_rt_m_source - se_rt_m_source, ymax = median_rt_m_source + se_rt_m_source),
width = 0.2,
position = position_dodge(0.8)
) +
# Add statistical comparison
#stat_pvalue_manual(
#  manual_p,
# label = "p = {p}",
#  tip.length = -0.01,
#  y.position = max(df_plot$accuracy, na.rm = TRUE) - 0.2
#) +
# Customize appearance
labs(
#title = "",
#subtitle = paste0("n = ", desc_stats$n[1], " participants"),
x = "treatment",
y = "median time for memorizing the source span (ms)",
caption = "Error bars = s.e. of the mean on each side"
) +
theme_pubr() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
) #+
# scale_y_continuous(
#limits = c(0, 1),
# breaks = seq(0, 1, 0.1),
# labels = scales::percent_format(accuracy = 1)
#)
}
rtMSourcePerTreatment <-makeRtMSourcePerTreatment(dataRtMSourcePerTreatment)
rtMSourcePerTreatment
ggsave(filename = file.path(PATH_TO_DATA, "Figures", "rtMSourcePerTreatment.pdf"),
plot = rtMSourcePerTreatment, device = "pdf", width = 12, height = 6)
makeRtMSourcePerTreatment <- function(data){
p <- ggbarplot(
data,
x = "treatment",
y = "mean_rt_m_source",
color = "treatment",
fill = "treatment",
palette = c("#00AFBB", "#E7B800"),
position = position_dodge(0.8),
alpha = 0.2,
size = 0.8,
width = 0.6,
) +
geom_errorbar(
aes(ymin = mean_rt_m_source - se_rt_m_source, ymax = mean_rt_m_source + se_rt_m_source),
width = 0.2,
position = position_dodge(0.8)
) +
# Add statistical comparison
#stat_pvalue_manual(
#  manual_p,
# label = "p = {p}",
#  tip.length = -0.01,
#  y.position = max(df_plot$accuracy, na.rm = TRUE) - 0.2
#) +
# Customize appearance
labs(
#title = "",
#subtitle = paste0("n = ", desc_stats$n[1], " participants"),
x = "treatment",
y = "mean time for memorizing the source span (ms)",
caption = "Error bars = s.e. of the mean on each side"
) +
theme_pubr() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
) #+
# scale_y_continuous(
#limits = c(0, 1),
# breaks = seq(0, 1, 0.1),
# labels = scales::percent_format(accuracy = 1)
#)
}
rtMSourcePerTreatment <-makeRtMSourcePerTreatment(dataRtMSourcePerTreatment)
rtMSourcePerTreatment
ggsave(filename = file.path(PATH_TO_DATA, "Figures", "rtMSourcePerTreatment.pdf"),
plot = rtMSourcePerTreatment, device = "pdf", width = 12, height = 6)
data_plot_precision_cogload <- final_data_2 %>%
filter(
block == "spanSpan" & task == "spanTest"
) %>%
group_by(subject, treatment) %>%
summarise (
accuracy_mean_participant = mean(accuracy, na.rm = TRUE),
#condition = c("Hard", "Easy")
) %>%
ungroup() %>%
mutate(
difference = t.test(accuracy_mean_participant ~ treatment, data =.)[['p.value']]
) %>%
group_by(treatment)%>%
summarise(
n = n(),
accuracy = mean(accuracy_mean_participant),
se = sd(accuracy_mean_participant)/sqrt(n),
p.value = difference[[1]]
) %>% ungroup()
data_plot_precision_cogload
# comparison cogload vs control on target task (span)
makeBarPlotCogLoadOnTargetAccuracy <- function (data) {
manual_p <- tibble(
group1 = "easy", group2 = "hard",
p= round(data$p.value[[1]],3))
plot <- ggbarplot(
data,
x = "treatment",
y = "accuracy",
color = "treatment",
fill = "treatment",
palette = c("#00AFBB", "#E7B800"),  # Easy = blue, Hard = yellow
position = position_dodge(0.8),
alpha = 0.2,
size = 0.8,
width = 0.6,
) +
geom_errorbar(
aes(ymin = accuracy - se, ymax = accuracy + se),
width = 0.2,
position = position_dodge(0.8)
) +
# Add horizontal line for chance level
geom_hline(
yintercept = 1/9,
linetype = "dashed",
color = "red",
linewidth = 1
) +
# Add chance level annotation
annotate(
"text",
x = 1.5,
y = 1/9 + 0.02,
label = paste0("Chance level = ", round(1/9, 3)),
color = "red",
size = 3.5
) +
# Add statistical comparison
stat_pvalue_manual(
manual_p,
label = "p = {p}",
tip.length = -0.01,
y.position = max(data$accuracy, na.rm = TRUE) - 0.2
) +
# Customize appearance
labs(
#title = "Accuracy target task (span): cogload vs baseline treatment",
#subtitle = paste0("n = ", desc_stats$n[1], " participants"),
x = "Block Difficulty",
y = "Accuracy",
caption = "Error bars represent s.e. of the mean\nRed dashed line shows theoretical chance level"
) +
theme_pubr() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
) +
scale_y_continuous(
limits = c(0, 1),
breaks = seq(0, 1, 0.1),
labels = scales::percent_format(accuracy = 1)
)
plot <- annotate_figure(plot, top = text_grob("Accuracy target task (span): cogload vs baseline treatment", face = "bold", size = 14))
return(plot)
}
barPlotCogLoadOnTargetAccuracy <- makeBarPlotCogLoadOnTargetAccuracy(data_plot_precision_cogload)
barPlotCogLoadOnTargetAccuracy
ggsave(filename = file.path(PATH_TO_DATA, "Figures", "barPlotCogLoadOnTargetAccuracy.pdf"),
plot = barPlotCogLoadOnTargetAccuracy, device = "pdf", width = 6, height = 5)
# analysis of the RT of choice on accuracy
makeScatterRTOnAccuracy <- function (data) {
plots <- list()
makeDataForPlotFunction <- function (df, treatment_filter=NULL) {
newDf <- df %>%
filter(!is.na(mplType) & !grepl("^(GS|AS|LS)", mplType)) %>% # starts_with doesn't work in filter, only for select
{if (!is.null(treatment_filter)) filter(., treatment == treatment_filter) else . }%>%
select(participant_id, mirror_rtChoice, lottery_rtChoice, mirror_rtSpanMpl, lottery_rtSpanMpl, mirror_accuracy, lottery_accuracy) %>%
# Pivot RTs only
pivot_longer(
cols = matches("_rt"),
names_to = c("condition", "rtType"),
names_pattern = "(mirror|lottery)_rt(.*)",
values_to = "rt"
) %>%
# Pivot accuracy only
pivot_longer(
cols = ends_with("accuracy"),
names_to = "condition_acc",
names_pattern = "(mirror|lottery)_accuracy",
values_to = "accuracy"
) %>%
# Keep matching accuracy per condition
filter(condition == condition_acc) %>%
select(-condition_acc)
}
plotFunctionRT <- function (df, ii){
title_string <- {
if (is.null(treatment_wanted) & ii == "Choice"){paste0("accuracy on RT memorization/choice")}
else if (is.null(treatment_wanted) & ii == "SpanMpl"){paste0("accuracy on RT restitution")}
else if(ii == "Choice" & treatment_wanted == "hard"){ paste0("accuracy on RT memorization/choice, cognitive load" )}
else if (ii == "SpanMpl" & treatment_wanted == "hard"){ paste0("accuracy on RT restitution, cognitive load" )}
else if (ii == "SpanMpl" & treatment_wanted == "easy"){ paste0("accuracy on RT restitution, control" )}
else if (ii == "Choice" & treatment_wanted == "easy"){ paste0("accuracy on RT memorization/choice, control" )}
}
cat("title_string", title_string, " with treatment_wanted =", treatment_wanted, " and ii = ", ii , "\n")
dfB <- df %>%
filter(rtType == ii)
cat("colnames(dfB) inside plotFunctionRT is", colnames(dfB), "\n" )
cat("nrow(dfB) inside plotFunctionRT is", nrow(dfB), "\n" )
cat("rt is", ii, "\n")
p <- ggscatter(
dfB,
x = "rt",
y = "accuracy",
#color = "letterType",
#fill = "letterType",
add = "reg.line",
add.params = list(color = "blue"),
) +
# Customize appearance
labs(
title = title_string,
#subtitle = paste0("n = ", desc_stats$n[1], " participants"),
x = paste0("reaction time"),
y = "accuracy",
#caption = "Error bars = s.e. of the mean on each side"
) +
theme_pubr() +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
) +
scale_y_continuous(
limits = c(0, 1),
breaks = seq(0, 1, 0.2),
labels = scales::percent_format(accuracy = 1)
)
}
accuracy_names <- c("accuracy")
treatments_wanted <- list(NULL, "hard", "easy")
plots <- list()
counter = 1
for (treatment_wanted in treatments_wanted) {
tidy_data <- makeDataForPlotFunction(data, treatment_wanted)
cat("tidy_data is created with treatment", treatment_wanted, "\n")
rt_names <- unique(tidy_data$rtType)
for (acc in accuracy_names){
for (rt_name in rt_names){
plots[[counter]] <- plotFunctionRT(tidy_data, rt_name)
counter <- counter + 1
}
}
}
combined <- ggpubr::ggarrange(plotlist = plots, ncol = 2, nrow = 3)
combined <- annotate_figure(combined, top = text_grob("Accuracy on RT with MPL as target", face = "bold", size = 14))
}
scatterRTOnAccuracy <- makeScatterRTOnAccuracy(dfA)
scatterRTOnAccuracy
ggsave(filename = file.path(PATH_TO_DATA, "Figures", "scatterRTOnAccuracy.pdf"),
plot = scatterRTOnAccuracy, device = "pdf", width = 12, height = 10)
# rt choices analysis
makeDataForRTChoice <- function (df, treatment_filter=NULL) {
newDf <- df %>%
filter(!is.na(mplType) & !grepl("^(GS|AS|LS)", mplType)) %>% # starts_with doesn't work in filter, only for select
{if (!is.null(treatment_filter)) filter(., treatment == treatment_filter) else . }%>%
select(participant_id, mirror_rtChoice, lottery_rtChoice, mirror_rtSpanMpl, lottery_rtSpanMpl, mirror_accuracy, lottery_accuracy, treatment) %>%
# Pivot RTs only
pivot_longer(
cols = matches("_rt"),
names_to = c("condition", "rtType"),
names_pattern = "(mirror|lottery)_rt(.*)",
values_to = "rt"
) %>%
# Pivot accuracy only
pivot_longer(
cols = ends_with("accuracy"),
names_to = "condition_acc",
names_pattern = "(mirror|lottery)_accuracy",
values_to = "accuracy"
) %>%
# Keep matching accuracy per condition
filter(condition == condition_acc) %>%
select(-condition_acc)
}
dataForRTChoice <-makeDataForRTChoice(dfA)
dataForRTChoice
dataRTCalibrateChoice <- dataForRTChoice %>%
filter(rtType== "Choice") %>%
pull(rt)
mean(dataRTCalibrateChoice<30000)
rm(list = ls())
